<Meta title="Getting Started/Contribute" />

#### Repository Structure 

| Directory | Summary |
| ----------- | ----------- |
| src | UI library source code, storybook, and unit-test source
| build | Holds the build files generated
| scripts | Build script
| storybook-static | Storybook build 
| src/utility | Template for a component which is used to automatically generate the source files for the component (Component.scss, Component.stories.tsx, Component.test.tsx, Component.tsx, Component.types.ts)
| src/components | All the reusable components
| src/Foundations | Storybook for design foundations
| src/TokensOld | Design tokens (Color, Typography, spacing, radius, border, etc.) 

#### Folder Structure of a component

| Directory/File | Summary
| ----------- | ----------- |
| TestComponent | Each directory in src is a component and it will contain only the component source files eg. TestComponent will contain these files.
| TestComponent.tsx |The component source file
| TestComponent.types.ts | Type definition of the component
| TestComponent.scss | CSS file for the component
| TestComponent.stories.tsx | Storybook for the component
| TestComponent.test.tsx | Unit test file for the component
| index.ts | The index file will import all the components and export 

### Development

#### Testing

```
yarn run test
```

#### Building

```
yarn run build
```

#### Storybook

To run a live-reload Storybook server on your local machine:

```
yarn run storybook
```

#### Generating New Components

A handy NodeJS utility file under `src/utility/generate/` called `generate-component.js` added to create a new component instead of manually copy pasting the existing component. You can instead run this command to generate all the files you need to start building out a new component. To use it:

```
npm run generate YourComponentName
```

This will generate:

```
src/components/
MyNewComponent/
  ├── MyNewComponent.overview.stories.tsx
  ├── MyNewComponent.scss
  ├── MyNewComponent.stories.tsx
  ├── MyNewComponent.test.tsx
  ├── MyNewComponent.tsx
  └── MyNewComponent.types.ts
```

The default templates for each file can be modified under `src/utility/generate/templates/`.


###### *For best code practices follow this article by Airbnb &lt;[Airbnb JavaScript Style Guide](https://airbnb.io/javascript/react/)&gt;*

### Branching and Tagging Policy
This repository uses standard git-flow branch management policy/strategy. If you want to learn more on git-flow, refer to the [tutorial from Atlassian](https://www.atlassian.com/git/workflows#!workflow-gitflow) and more details at http://nvie.com/posts/a-successful-git-branching-model/.
### Commit Guidelines
The following best practices, coupled with a pinch of common sense, will keep the repository clean and usable in the future. The idea is that everything that goes into the repository is not just for an individual, but also someone else, who will be directly or indirectly affected by it.
### Check for Errors Before Committing
Checking for errors should be done for each commit, whether or not it is being pushed to remote.
You should submit only the required changes. Git provides an easy way to check for this — before you commit, run git diff --check, which identifies all changes done to the file. Remove changes that are not required. You can also use the VSCode git tool to see the changes.
You must check whether any Lint error is highlighted. If yes, that means you have written code that does not follow the standard. Modify the changes as per standard. Install the VSCode plugin which will help you to identify lint errors.
You should ensure that your commit does not break builds. Run npm test on the repository to execute all sanity and smoke tests. If any test fails, do not change the test to pass your commit. The tests are there for a reason. Discuss within your team to ensure that the changes that you do to test specs are valid. If you are adding a new feature, make sure to write a test case for that.
### Atomic Commits
Try to make each commit a logically separate changeset. If you can, try to make your changes digestible — don't code for a whole weekend on five different issues and then submit them all as one massive commit on Monday. Even if you don't commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit. If some of the changes modify the same file, try to use git add --patch to partially stage files. The project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make things easier on your fellow developers when they have to review your changes. This approach also makes it easier to pull out or revert one of the changesets if you need to later. There are a number of useful Git tricks for rewriting history and interactively staging files. Use these tools to help craft a clean and understandable history.
### Clean Commit Message
Clean and detailed explanations of commit messages makes using and collaborating with Git a lot easier. As a general rule, the commit messages should start with a single line that should not be more than about 50 characters, followed by a blank line, followed by a more detailed explanation.
The commit message should answers the following questions:
- Why is this change necessary?
- How does it address the issue?
- What side effects does this change have?

The first question tells reviewers of your pull request what to expect in the commit, allowing them to easily identify and point out unrelated changes.
The second question describes, at a high level, what was done to affect the change. If your change is obvious, you may be able to omit addressing this question.
The third is the most important question to answer, as it can point out problems where you are making too many changes in one commit or branch. One or two bullet points for related changes may be okay, but five or six are likely indicators of a commit that is doing too many things.
Run git log --no-merges to see what a nicely formatted project-commit history looks like.

### Guidelines for Sending a Pull Request
A pull request should not be accepted with a test failure. Ensure that the npm test passes on the head of your feature branch.
Ensure that your feature branch has been tested and if it is associated with issues from Jira
Pull request messages and commit messages should explicitly describe what changes were made. If required attach the screenshots along with.
You may refer to https://confluence.atlassian.com/display/BITBUCKET/Work+with+pull+requests for basics on sending Pull Request on BitBucket.
